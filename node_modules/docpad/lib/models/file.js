// Generated by CoffeeScript 1.3.3
(function() {
  var FileModel, Model, balUtil, fsUtil, mime, pathUtil, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  pathUtil = require('path');

  fsUtil = require('fs');

  balUtil = require('bal-util');

  _ = require('underscore');

  mime = require('mime');

  Model = require(__dirname + '/../base').Model;

  FileModel = (function(_super) {

    __extends(FileModel, _super);

    function FileModel() {
      return FileModel.__super__.constructor.apply(this, arguments);
    }

    FileModel.prototype.outDirPath = null;

    FileModel.prototype.type = 'file';

    FileModel.prototype.logger = null;

    FileModel.prototype.stat = null;

    FileModel.prototype.defaults = {
      id: null,
      basename: null,
      extension: null,
      extensions: null,
      filename: null,
      fullPath: null,
      fullDirPath: null,
      outPath: null,
      relativePath: null,
      relativeDirPath: null,
      relativeBase: null,
      contentType: null,
      data: null,
      encoding: null,
      content: null,
      title: null,
      date: null,
      slug: null,
      url: null,
      urls: null,
      ignored: false
    };

    FileModel.prototype.initialize = function(data, options) {
      this.logger = options.logger, this.outDirPath = options.outDirPath, this.stat = options.stat;
      this.set({
        extensions: [],
        urls: []
      });
      return FileModel.__super__.initialize.apply(this, arguments);
    };

    FileModel.prototype.getAttributes = function() {
      return this.toJSON();
    };

    FileModel.prototype.getMeta = function() {
      return this.meta;
    };

    FileModel.prototype.isText = function() {
      return this.get('encoding') !== 'binary';
    };

    FileModel.prototype.isBinary = function() {
      return this.get('encoding') === 'binary';
    };

    FileModel.prototype.load = function(next) {
      var complete, data, filePath, fullPath, logger,
        _this = this;
      filePath = this.get('relativePath') || this.get('fullPath') || this.get('filename');
      fullPath = this.get('fullPath');
      data = this.get('data');
      logger = this.logger;
      logger.log('debug', "Loading the file: " + filePath);
      complete = function(err) {
        if (err) {
          return typeof next === "function" ? next(err) : void 0;
        }
        logger.log('debug', "Loaded the file: " + filePath);
        return typeof next === "function" ? next() : void 0;
      };
      pathUtil.exists(fullPath, function(exists) {
        if (exists) {
          return _this.readFile(fullPath, complete);
        } else {
          return _this.parseData(data, function(err) {
            if (err) {
              return typeof next === "function" ? next(err) : void 0;
            }
            return _this.normalize(function(err) {
              if (err) {
                return typeof next === "function" ? next(err) : void 0;
              }
              return complete();
            });
          });
        }
      });
      return this;
    };

    FileModel.prototype.readFile = function(fullPath, next) {
      var file, logger, relativePath, tasks,
        _this = this;
      logger = this.logger;
      file = this;
      fullPath = this.get('fullPath');
      relativePath = this.get('relativePath');
      logger.log('debug', "Reading the file: " + relativePath);
      tasks = new balUtil.Group(function(err) {
        if (err) {
          logger.log('err', "Failed to read the file: " + relativePath);
          return typeof next === "function" ? next(err) : void 0;
        } else {
          return _this.normalize(function(err) {
            if (err) {
              return typeof next === "function" ? next(err) : void 0;
            }
            logger.log('debug', "Read the file: " + relativePath);
            return typeof next === "function" ? next() : void 0;
          });
        }
      });
      tasks.total = 2;
      if (file.stat) {
        tasks.complete();
      } else {
        balUtil.stat(fullPath, function(err, fileStat) {
          if (err) {
            return typeof next === "function" ? next(err) : void 0;
          }
          file.stat = fileStat;
          return tasks.complete();
        });
      }
      balUtil.readFile(fullPath, function(err, data) {
        if (err) {
          return typeof next === "function" ? next(err) : void 0;
        }
        return file.parseData(data, tasks.completer());
      });
      return this;
    };

    FileModel.prototype.getEncoding = function(buffer) {
      var charCode, contentStartBinary, contentStartUTF8, encoding, i, _i, _ref;
      contentStartBinary = buffer.toString('binary', 0, 24);
      contentStartUTF8 = buffer.toString('utf8', 0, 24);
      encoding = 'utf8';
      for (i = _i = 0, _ref = contentStartUTF8.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        charCode = contentStartUTF8.charCodeAt(i);
        if (charCode === 65533 || charCode <= 8) {
          encoding = 'binary';
          break;
        }
      }
      return encoding;
    };

    FileModel.prototype.parseData = function(data, next) {
      var backup, content, encoding;
      backup = this.toJSON();
      this.clear();
      encoding = 'utf8';
      this.set({
        data: data,
        basename: backup.basename,
        extension: backup.extension,
        extensions: backup.extensions,
        filename: backup.filename,
        fullPath: backup.fullPath,
        outPath: backup.outPath,
        relativePath: backup.relativePath,
        relativeBase: backup.relativeBase,
        contentType: backup.contentType,
        urls: []
      });
      if (data instanceof Buffer) {
        encoding = this.getEncoding(data);
        if (encoding === 'binary') {
          content = '';
        } else {
          content = data.toString(encoding);
        }
      } else if (typeof data === 'string') {
        content = data;
      } else {
        content = '';
      }
      content = content.replace(/\r\n?/gm, '\n').replace(/\t/g, '    ');
      this.set({
        content: content,
        encoding: encoding
      });
      if (typeof next === "function") {
        next();
      }
      return this;
    };

    FileModel.prototype.addUrl = function(url) {
      var existingUrl, found, newUrl, urls, _i, _j, _len, _len1;
      if (url instanceof Array) {
        for (_i = 0, _len = url.length; _i < _len; _i++) {
          newUrl = url[_i];
          this.addUrl(newUrl);
        }
      } else if (url) {
        found = false;
        urls = this.get('urls');
        for (_j = 0, _len1 = urls.length; _j < _len1; _j++) {
          existingUrl = urls[_j];
          if (existingUrl === url) {
            found = true;
            break;
          }
        }
        if (!found) {
          urls.push(url);
        }
      }
      return this;
    };

    FileModel.prototype.removeUrl = function(userUrl) {
      var index, url, urls, _i, _len;
      urls = this.get('urls');
      for (index = _i = 0, _len = urls.length; _i < _len; index = ++_i) {
        url = urls[index];
        if (url === userUrl) {
          urls.remove(index);
          break;
        }
      }
      return this;
    };

    FileModel.prototype.normalize = function(next) {
      var basename, contentType, date, extension, extensions, filename, fullDirPath, fullPath, id, relativeBase, relativeDirPath, relativePath;
      basename = this.get('basename');
      filename = this.get('filename');
      fullPath = this.get('fullPath');
      relativePath = this.get('relativePath');
      id = this.get('id');
      date = this.get('date');
      fullPath || (fullPath = filename);
      relativePath || (relativePath = fullPath);
      filename = pathUtil.basename(fullPath);
      basename = filename.replace(/\..*/, '');
      extensions = filename.split(/\./g);
      extensions.shift();
      extension = extensions.length ? extensions[extensions.length - 1] : null;
      fullDirPath = pathUtil.dirname(fullPath) || '';
      relativeDirPath = pathUtil.dirname(relativePath).replace(/^\.$/, '') || '';
      relativeBase = relativeDirPath.length ? pathUtil.join(relativeDirPath, basename) : basename;
      id || (id = relativePath);
      if (this.stat) {
        date || (date = new Date(this.stat.mtime));
      }
      contentType = mime.lookup(fullPath);
      this.set({
        basename: basename,
        filename: filename,
        fullPath: fullPath,
        relativePath: relativePath,
        fullDirPath: fullDirPath,
        relativeDirPath: relativeDirPath,
        id: id,
        relativeBase: relativeBase,
        extensions: extensions,
        extension: extension,
        contentType: contentType,
        date: date
      });
      if (typeof next === "function") {
        next();
      }
      return this;
    };

    FileModel.prototype.contextualize = function(next) {
      var extensions, filename, name, outPath, relativeBase, slug, url;
      relativeBase = this.get('relativeBase');
      extensions = this.get('extensions');
      filename = this.get('filename');
      url = null;
      slug = null;
      name = null;
      outPath = null;
      url || (url = extensions.length ? "/" + relativeBase + "." + (extensions.join('.')) : "/" + relativeBase);
      slug || (slug = balUtil.generateSlugSync(relativeBase));
      name || (name = filename);
      outPath = this.outDirPath ? pathUtil.join(this.outDirPath, url) : null;
      this.addUrl(url);
      this.set({
        url: url,
        slug: slug,
        name: name,
        outPath: outPath
      });
      if (typeof next === "function") {
        next();
      }
      return this;
    };

    FileModel.prototype.write = function(next) {
      var content, fileOutPath, logger;
      logger = this.logger;
      fileOutPath = this.get('outPath');
      content = this.get('content') || this.get('data');
      logger.log('debug', "Writing the file: " + fileOutPath);
      balUtil.writeFile(fileOutPath, content, function(err) {
        if (err) {
          return typeof next === "function" ? next(err) : void 0;
        }
        logger.log('debug', "Wrote the file: " + fileOutPath);
        return typeof next === "function" ? next() : void 0;
      });
      return this;
    };

    return FileModel;

  })(Model);

  module.exports = FileModel;

}).call(this);
